function visStruc = ytla_Import(dataName,fileName,souName,purpLab,varargin)
%% ytla_Import - Construct the visibility super-structure from raw YTLA data
%% Vis_Construct -  original code for importing MIRIAD SZA data into matlab format
%
% This primary function is used to convert the native format of the data into
% the format that is used in all of the processing in all of the scripts. As
% such, most of the code here simply behaves like "plumbing", directing the
% right field in the native format to the correct field in the SZA-CO format.
%
% This function does not produce any outputs, but insteads puts the visibilities
% into a folder called 'divy/{obsName}', where obsName is the name of the
% observation block in question. In that folder is a subfolder for each source,
% and a file called 'culm.mat', which records the source names and purposes for
% each visibility folder that is produced.
%
% INPUT PARAMETERS:
%     dataName,souName -- saves into 'divy/dataName/souName/vis.mat'
%     fileName -- Name of the file that contains the native data structure. This
%         needs to be separate from the folder because Matlab has difficulties
%         with paths.
%     purpLab -- 'S': science; 'G': gain; 'B': bandpass; 'F': flux
%         
% OUTPUT PARAMETERS:
%     None (records)
% OTHER ROUTINES CALLED:
%     None
%
% BUGS/TO DO:
%     - Perhaps make it so that this function has an output if requested
%
% RESPONSIBLE: Kyle Lin
%	       Geoff Bower
%              Karto Keating (karto@astro.berkeley.edu)
%

    hostName = getenv('HOST');

    timeStamp = clock;
    timeStamp = [timeStamp(2), timeStamp(3), mod(timeStamp(1),100),...
	timeStamp(4), timeStamp(5), round(timeStamp(6))];

    % constants
    boltzK = 1.3806503*10^-16; %CGS
    speedC = 29979245800; %CGS


    % defaults of optional arguments
    overwrite = false;
    rewrite = false;

    % Process optional arguments
    nvar = numel(varargin);
    if (mod(nvar,2)==0)
	for idx=1:2:numel(varargin)
	    tempVal = varargin{idx+1};
	    eval([varargin{idx}, '=tempVal;'])
	    clear tempVal;
	end
    else
	fprintf('varargin should come in pairs.\n')
	return
    end
    if isempty(hostName)
	display('error getting hostName. please supply explicitly.')
	return
    end
    fprintf('hostName = %s\n', hostName)


    % Do some parsing to get the names of things
    %fileName = char(fileName);
    %dataName = fileName ;
    if not(exist('dataName', 'var'))
	fprintf('dataName not provided\n')
	return
    end
    if not(exist('fileName', 'var'))
	fprintf('fileName not provided\n')
	return
    end
    if not(exist('souName', 'var'))
	fprintf('souName not provided\n')
	return
    end
    if not(exist('purpLab', 'var'))
	fprintf('purpLab not provided\n')
	return
    end
    

    if exist(char(strcat('divy/',dataName)),'dir')
	if overwrite
	    rmdir(char(strcat('divy/',dataName)),'s')
	%elseif not(rewrite)
	%    error('Vis directory already exists!')
	end
    else
	mkdir('divy',dataName)
    end

    % The naming scheme in the native structure changes slightly, so figure out
    % what it should be, and load the file.
    fprintf('Loading file: %s ...\n', fileName)
    ytla = ytlaLoadh5(fileName)
    Tsys = ytlaTsys(ytla);
    disp('done!')

    run('ytlaConf.m');
	
    ant1Arr = zeros(1,nBase);
    ant2Arr = zeros(1,nBase);
    baseToAnts = zeros(nBase, nAnts);

    idx = 0;
    for ai = 1:nAnts-1
	for aj=ai+1:nAnts
	    idx = idx + 1;
	    ant1Arr(1,idx) = ai;
	    ant2Arr(1,idx) = aj;
	    baseToAnts(idx, [ai aj]) = [1 -1];
	end
    end


    %% define some important quantities
    nTime = numel(ytla.epochTime);
    dt = datetime(ytla.epochTime, 'convertfrom', 'posixtime');
    jd = juliandate(dt);
    mjdTime = jd - 2400000.5 ;
    lstTime = 24*calc_lst(jd,mlo.long)' ;

    crossVis = ytla.cross ;
    autoVis  = ytla.auto ;

    intTime = ytla.pnt.tint;	    % sec

    sysTemps = nan(nTime,nAnts,nWin);
    sourceNames = ytla.target;
    switch purpLab
      case 'S'
        purpvalue=1 ;
      case 'G'
        purpvalue=2 ;
      case 'B'
        purpvalue=16 ;
      case 'F'
        purpvalue=32 ;
    end
    sourcePurps = uint32(ones(nTime,1))*purpvalue;
    sourceRA  = ytla.pnt.ra;    % decimal hour, apparent
    sourceDec = ytla.pnt.dec;   % decimal degree, apparent


    %chFreq = repmat(chFreq*ones(nWin,1),[1 nChan])+...
    %    (delFreq.*repmat(floor((nChan-1)/2):-1:floor((1-nChan)/2),[nWin 1]));
    %% note: size(chFreq) = (nwin, nChan)
    ch = 1:nChan;
    chFreq = zeros(nWin, nChan);
    chFreq(1,:) = -delFreq * (ch - 1.);	    % Baseband freq in Hz
    chFreq(2,:) =  delFreq * (ch - 1.);
    centFreq = ytla.LO * 1.e6 + 84.0e9;	    % central freq in Hz
    chFreq = chFreq + centFreq;		    % radio freq in Hz


    %% need to calculate u,v,w from antXYZ, LST, etc
    %uVals = zeros(nTime,nBase,nWin,nChan);
    %vVals = zeros(nTime,nBase,nWin,nChan);
    %wVals = zeros(nTime,nBase,nWin,nChan);
    %[uVals,vVals,wVals]=calc_uvw(antXYZ,baseToAnts,chFreq,sourceRA,sourceDec,lstTime);
    %% xPos, yPos are defined in ytlaConf.m
    skypol = ytla.pnt.sp;
    [uVals, vVals, wVals] = ytla_uvw(xPos, yPos, skypol, centFreq);

    % without specifying 'obsFreq' in Hz, the default is for 1cm
    [~,~,omegaBeam1cm,omegaBeamSq1cm] = calc_primarybeam('YTLA', 'sameAnt', true);
    omegaBeam1cm = repmat(omegaBeam1cm, [1 nBase]);
    omegaBeamSq1cm = repmat(omegaBeamSq1cm, [1 nBase]);



    fprintf('ready for data split!\n')

    % For each unique source, start populating the scructure
    for idx=1:1
	% Figure out which integration corresponds to the source in question,
	% without things like noisecals and other garbage.

	metaData = struct(...
	    'nTime',nTime,...
	    'nBase',nBase,...
	    'nAnts',nAnts,...
	    'nWin',nWin,...
	    'nChan',nChan,...
	    'nPlat',nPlat,...
	    'freq',chFreq,...
	    'delFreq',delFreq,...
	    'ant1Arr',ant1Arr,...
	    'ant2Arr',ant2Arr,...
	    'baseToAnts',baseToAnts,...
	    'edgeChan',0,...
	    'basePol',-2*ones(1,nBase),...
	    'omegaBeam1cm',omegaBeam1cm,...
	    'omegaBeamSq1cm',omegaBeamSq1cm,...
	    'hostName',hostName,...
	    'timeStamp',timeStamp);

	% Generate a dummy table for the flags
	spur0 = uint8(zeros(nTime,nBase,nWin,nChan)+(128.*...
            or(eq(crossVis(:,:,:,:),0),not(isfinite(crossVis(:,:,:,:))))));
	spur1 = cast(ytla.flag, 'uint8');
	flags = struct(...
	    'spur',spur1,...
	    'rfi',uint8(zeros(nTime,1,nWin,nChan)),...
	    'win',uint8(zeros(nTime,nBase,nWin)),...
	    'base',uint8(zeros(nTime,nBase)),...
	    'ant',uint8(zeros(nTime,nAnts)),...
	    'time',uint8(zeros(nTime,1)),...
	    'meta',uint8(zeros(1,nAnts,nWin,nChan)),...
	    'hostName',hostName,...
	    'timeStamp',timeStamp);
	    
	% Generate a structure full of source information
	source = struct(...
	    ...%'name',sourceNames,...
	    'name',souName,...
	    'ra',sourceRA,...
	    'dec',sourceDec,...
	    'raApp',sourceRA,...
	    'decApp',sourceDec,...
	    'epoch',2000*ones(nTime,1),...
	    'purpose',sourcePurps);
	%source.name = sourceNames;

	% Generate a structure full of antenna information
	dummyAnt = false;
	if exist('antXYZ', 'var')
	    if isempty(antXYZ)
		dummyAnt = true;
	    end
	else
	    dummyAnt = true;
	end
	if dummyAnt
	    antXYZ = zeros(nTime, nAnts, 3);
	end
	antData = struct(...
	    'apEff',repmat(0.5,[nWin nAnts])',...
	    'corrEff', ones(1, nWin),...
	    'antXYZ',antXYZ,...
	    ...%'tsys',200*ones(nTime,nAnts,nWin),...
	    'tsys',Tsys,...
	    'azErr',zeros(nTime,nAnts),...
	    'elErr',zeros(nTime,nAnts),...
	    'antScale',ones(1,nAnts),...
	    'antPol',int8(ones(1,nAnts)*-10),...
	    'antPlatNum',ones(1,nAnts),...
	    'antPlatOffset',antPlatOffset,...
	    'hostName',hostName,...
	    'timeStamp',timeStamp);
	antType = repmat({'YTLA'}, [1, nAnts]);
	antData.antType = antType;
	antID = arrayfun(@num2str,1:nAnts,'UniformOutput',false);
	antData.antID = antID;

	% separate the baseline coordinates
	baseCoords = struct(...
	    'u',uVals,...
	    'v',vVals,...
	    'w',wVals);

	% platform info
	dummyPlat = false;
	if exist('platXYZ', 'var')
	    if isempty(platXYZ)
		dummyPlat = true;
	    end
	else
	    dummyPlat = true;
	end
	if dummyPlat
	    platXYZ = zeros(0,3);
	    platAzErr = zeros(nTime,0);
	    platElErr = zeros(nTime,0);
	    platAzRot = zeros(nTime,0);
	    platTipDir = zeros(nTime,0);
	    platTipRot = zeros(nTime,0);
	    platZRot = zeros(nTime,0);
	end
	platData = struct(...
	    'platXYZ',platXYZ,...
	    'azErr',platAzErr,...
	    'elErr',platElErr,...
	    'azRot',platAzRot,...
	    'tipDir',platTipDir,...
	    'tipRot',platTipRot,...
	    'zRot',platZRot);



	% Generate a structure full of site information
	siteData = struct(...
	    'tau',zeros(nTime,1),...
	    'lat',mlo.lat,...
	    'long',mlo.long,...
	    'elev',mlo.alt,...
	    'obsName',dataName);
	
	% Generate a structure full of time information
	time = struct(...
	    'mjd',mjdTime,...
	    'inttime',intTime,...
	    'lst',lstTime);
	
	% Create a dummy gains structure
	gainPrefs = struct(...
	    'chanAmpInterp','equal',...
	    'chanPhaInterp','equal',...
	    'chanMaxDelta',0.15,...
	    'chanTimeGood',1440,...
	    'chanTimeMaxInt',1440,...
	    'chanBadStrategy','halfflag',...
	    'chanScaleNoise',false,...
	    'winAmpInterp','interplin',...
	    'winPhaInterp','interplin',...
	    'winMaxDelta',0.15,...
	    'winTimeGood',45,...
	    'winTimeMaxInt',360,...
	    'winBadStrategy','proxflag',...
	    'winScaleNoise',true,...
	    'antAmpInterp','interplin',...
	    'antPhaInterp','interplin',...
	    'antMaxDelta',0.15,...
	    'antTimeGood',45,...
	    'antTimeMaxInt',360,...
	    'antBadStrategy','proxflag',...
	    'antScaleNoise',true,...
	    'gainPrefSou',[],...
	    'gainPrefList',[]);
	gainPrefs.gainPrefSou = cell(0);
	gainPrefs.gainPrefList = cell([0,3]);
	gainStruc = struct(...
	    'gainAntSoln',zeros(1,nAnts),...
	    'gainWinSoln',zeros(1,nAnts,nWin),...
	    'gainChanSoln',zeros(1,nAnts,nWin,nChan),...
	    'gainDelaySoln',zeros(1,nAnts,nWin),...
	    'gainSou',[],...
	    'gainTime',[],...
	    'gainType',[],...
	    'gainRefAnt',0,...
	    'noiseSpec',ones(1,nAnts,nWin,nChan),...
	    'noiseCorr',repmat(shiftdim(eye(nChan),-1),[nWin 1 1]),...
	    'apEffCorr',ones(nAnts,nWin),...
	    ...%'gainPrefs',gain_pref_defaults(),...
	    'gainPrefs',gainPrefs,...
	    ...%'gainCovar',zeros(1,2*nAnts,2*nAnts,nWin,nChan),...
	    'hostName',hostName,...
	    'timeStamp',timeStamp);

	% Generate a structure with u/v/w coordinates
	baseCoords = struct(...
	    'u',uVals,...
	    'v',vVals,...
	    'w',wVals);


	% Produce the visibility super-structure
	visStruc = struct(...
	    'baseCoords',baseCoords,...
	    'cross',crossVis,...
	    'auto',autoVis,...
	    'gains',gainStruc,...
	    'antData',antData,...
	    'platData',platData,...
	    'siteData',siteData,...
	    'source',source,...
	    'flags',flags,...
	    'time',time,...
	    'special',struct(),...
	    'metaData',metaData);

	    sourceDir = char(strcat('divy/',dataName,'/',souName));
	    if not(exist(sourceDir,'dir'))
		mkdir(sourceDir)
	    end
	    save(char(strcat(sourceDir,'/','vis.mat')),'-struct','visStruc') ;
	    fprintf('Data for %s written to %s!\n', souName, sourceDir) ;
    end
	
end

